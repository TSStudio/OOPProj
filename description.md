# sfSnake 修改版

## 编译说明

此程序针对 64 位 Linux 编写。于 Ubuntu 22.04 AMD64 环境测试。注意：鉴于 Gitee “审核” 的不稳定性和 GitHub 国内访问的不稳定性，本编译说明不使用 CMake 的 FetchContent，而是基于各个发行版的包仓库（这些仓库均有国内镜像）。  
您的运行环境必须支持 OpenGL 计算和显示输出。

#### 对于 Debian 系 Linux 系统的编译指南：  
您应当事先有编译的基础套件（build-essential、gcc 和 g++ 13 以上、CMake 3.16 以上）。
若没有，请先安装。安装请执行以下命令
```
sudo apt-get update
sudo apt-get install build-essential gcc-13 g++-13 cmake
```
您需要使用以下命令将 gcc/g++13 设为最高优先级的 gcc/g++
```
update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-13 100
update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-13 100
```
或者使用以下命令手动选择
```
update-alternatives --config g++
update-alternatives --config gcc
```
在有编译套件后，请确保有本程序所需要的库，执行以下命令
```
sudo apt update
sudo apt install \
    libxrandr-dev \
    libxcursor-dev \
    libudev-dev \
    libopenal-dev \
    libflac-dev \
    libvorbis-dev \
    libgl1-mesa-dev \
    libegl1-mesa-dev \
    libdrm-dev \
    libgbm-dev \
    libfreetype-dev \
    libfreetype6 \
    libsfml-dev
sudo apt-get install pkg-config
```
使用以下命令生成 Makefile（请确保 shell 目录在本程序根目录内）：
```
cmake .
```
使用以下命令构建：
```
make
```
如果您使用多核心 CPU，请改为使用类似以下的命令（对于 16 核心）进行多线程编译：
```
make -j16
```
您应当可以看到一个可执行文件（`sfSnake`）位于当前目录中。

#### 对于其他支持包管理的系统（例如yum）
您应当通过自己的包管理系统安装上述包，构建命令是一样的。

#### 对于其他系统
您应当手动安装所需的库到 CMake 的 find_package() 的搜索路径中，构建命令是一样的。

## 更改的部分

### 自写代码量

应当查看 https://github.com/TSStudio/OOPProj 中的 Commit 记录（https://github.com/TSStudio/OOPProj/commits/master/）。从 5 月 7 日起的 c607e17 号 commit 开始为自写代码。此处注：5 月 6 日的 2 个 Commit 是为了使得代码可以编译而做出的最小改动，以及对代码进行格式化，以符合我个人定义的代码格式（这是我个人所有C/C++项目使用的代码格式，类似于 Google，见.clang-format）。  
我应当会在提交截止之时将该仓库更改为 Public。如果忘记了而没有，烦请老师提醒我，非常抱歉。


#### 帧率
源程序以 10 帧运行。修改后以 60 帧运行。为了配合这一点，蛇的节点的移动逻辑也做了修改。原来是每帧移动到上一节点的位置，现在改为每帧移动到上一虚拟节点的位置，每两个节点中间相隔 5 个虚拟节点。

#### 贪食蛇的控制
源代码只支持 4 个方向的运行，增加可以通过鼠标控制贪食蛇的运动。当按下鼠标键时，设置一个方向向量，该方向向量为鼠标所在位置(MousePosition)与蛇头所在位置(SnakePosition)的差值。对于修改帧率后，下一时刻（1/60 秒后），贪食蛇按照该向量的方向运动；运动的距离为 1/6 个标准单位（标准单位：一个蛇节点的直径）。

#### 加速
在长度大于 2 时，玩家可以按 Space 键使蛇以 2 倍的速度前进，此时每帧额外消耗 0.002 的长度。长度不足 2 时，按键无效。

#### 碰撞判定
原来自身碰撞会导致死亡。现在去除了自身碰撞的判定，即允许碰撞自身（至于为什么这样修改，请参考“整体玩法”部分）。

原来碰撞墙壁会从另一边穿出，现在碰撞墙壁会死亡。

#### 长度自然流逝
长度将以 0.002 每帧的速度减小。因此长度（得分）改为以浮点数存储，实际存在的节点数为floor(长度)。

#### 死亡判定
长度不足 1 的情况也判定为死亡，此时得分为 1。

#### 绘制精灵版本的贪食蛇
源代码中的贪食蛇绘制过于简单—仅仅使用了矩形绘制。更改了贪食蛇的绘制方法，头部使用图片，通过 sprite 进行绘制，其余部分使用园叠加黑色的矩形块绘制。其中玩家蛇默认为绿色，AI 蛇为红色。

#### 水果的控制
源代码只支持 1 种水果，颜色随机且贪食蛇增加的长度固定。现增加黑色、棕色、红、蓝色、绿色、共 5 种水果，且贪食蛇吃了黑色、棕色水果不增加其长度，红色、蓝色、绿色水果增加的长度分别为 3、2、1；增加的长度在贪食蛇的尾部—假设初始是叠加在一起的。
系统随机生成上述 5 种水果，保持黑色和褐色水果所占比例为 25%，其他的占 75%。

#### 游戏界面的修改
可以修改背景的颜色（提供白色、黑色、褐色三种），按 Q 切换；允许显示（或关闭显示）网格，按 W 切换；网格的颜色可以设置（提供白色、黑色、褐色三种），按 E 切换。  

左上角显示保留两位小数的得分（长度）。

将所有字体改为 Arial，增加可读性。

#### 菜单页面
菜单现在使用“选择”形式，而非按下特定按键。选择使用一个非线性动画执行。选择逻辑和动画是分离的，即如果在播放动画时选择动了多次，动画执行完毕后会直接执行到最新选项的动画，最大延迟为 2 倍动画长度。

#### 动画类
实现了一个动画类（Animation），便于计算动画平滑过渡值。采用非线性动画。

#### 游戏结束页面
与菜单页面统一设计，且提供了返回菜单的选项。

#### 保存最高分功能
最高分会写入文件 gamedat.dat 中，以 4 个字节存储一个 int。

#### 其他（AI）蛇
AI 蛇，理想化地，应当模拟其他玩家加入游戏的行为，但由于时间受限只制作了1条，不会躲避玩家。AI蛇的目标果实为：根据 营养值*100-曼哈顿距离 排序后最大的果实。
AI 蛇被击杀后（即 AI 蛇头撞击了玩家蛇），每个节点有 50% 几率掉落一个绿色水果。

#### 音乐
修改了所有的音乐。另外修改了音乐的逻辑：  
游戏音乐、菜单音乐是分离的。游戏结束界面不播放音乐。  
在玩家击杀 AI 蛇后，暂停背景音乐，播放动感音乐（Power Music），约 12 秒，然后恢复播放背景音乐。

#### 整体玩法
原来碰撞自身会死亡，本质上是要**迫使玩家进行操作**。为了降低难度以及增加趣味性，使用了其他方法**迫使玩家进行操作**。  
玩家必须进行操作的原因在于 3 点：  
1.玩家如果不操作，蛇会撞墙。  
2.会被其他玩家所阻挡（或故意困杀）。  
3.蛇长度会自然消逝，如果不被

从这也可以看出来，这个游戏实际上是为了多人游戏打造的。但由于时间限制，我没有完成网络协议，或者是一个可以和玩家玩战术的 AI。而是只有一个傻傻的电脑蛇。这个玩法的成品可以参考贪吃蛇大作战/slither.io。

#### Timings
这是一个用于调试的性能监视器。允许对每一帧的各个环节进行计时，以发现性能瓶颈，设计此功能是为了排查出下列 bug 中的“渲染性能”。按 B 即可对当前帧进行 Timings，并输出到标准输出流。形式类似于 StackTrace，参考了 Minecraft 的性能分析器设计。

## 修复的 bug

#### 渲染性能
例如在原来的代码中，绘制身体节点是：
```C++
void Snake::render(sf::RenderWindow& window)
{
	for (auto node : nodes_)
		node.render(window);
}
```
但实际上不需要拷贝，这严重影响性能（绘制时间为十毫秒级，不拷贝只需要亚毫秒级），故改为：
```C++
void Snake::render(sf::RenderWindow& window)
{
	for (auto& node : nodes_)
		node.render(window);
}
```
同理，绘制水果也有此问题，也进行了修改。

#### 随机 bug
原先的水果生成的 y 会出现在同一个高度。现在为游戏全局增加了一个随机数生成器，所有随机数均由此产生，增加了随机性，同时解决了随机 bug。

#### 拷贝 bug
原先的 SnakeNode 会存储在 vector 中，但并没有定义拷贝构造函数（虽然原来也的确不需要深拷贝，但为了渲染 Sprite 需要改动）（因为 SFML 会把 texture 的地址保存），这会导致 vector 扩张拷贝内存时导致 Sprite 指向 Texture 的指针变为野指针。

#### 弃用的方法
`sf::Text::setColor` 已弃用，改为 `sf::Text::setFillColor`。